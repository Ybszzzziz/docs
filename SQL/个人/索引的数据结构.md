## 索引的数据结构

#### 1.索引及优缺点

##### 1.1 索引概述

​	MySQL官方对索引的定义为：**索引是帮助MySQL高效获取数据的数据结构**。

​	**索引的本质**：索引是数据结构，可以理解为是“排好序的快速查找数据结构”，满足特定查找算法，这	些数据结构以某种方式指向数据，这样就可以在这些数据结构的基础上实现**高级查找算法**。

##### 1.2 索引的优点

- 提高数据的检索效率，降低数据库IO成本
- 通过创建唯一索引，能够保证数据库中表的每一行的唯一性
- 减少查询中分组和排序的时间

##### 1.3 索引的缺点

- 创建索引和维护索引耗费时间
- 占用磁盘空间
- 虽然索引会大大提高查询速度，但是会降低更新表的速度，对表中数据进行增删改时，需要动态的维护索引。

##### 1.4 实操对比

​	在 student 表中有50000条数据，使用查询classId 为267的学生姓名、年龄，以下是未使用索引的查询	时间：

​											![image-20230815164705574](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815164705574.png)

​	创建索引：![image-20230815164841702](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815164841702.png)

​	再次查询：![image-20230815164906393](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815164906393.png)



#### 2. InnoDB 中的索引推演

##### 2.1 索引之前的查找

 1. 在一个页中的查找 

    由于没有索引，所以要查询数据只能遍历整张表，找到符合要求的数据。

 2. 在很多页中的查找

    由于不能快速的定位到要查询的数据所在的页，所以只能从**第一个页**沿着双向链表一直往下找，在每一个页中根据上面的查找方式区查找指定的记录，因为要遍历所有的数据页，所以是非常耗时的。

##### 2.2 设计索引

```mysql
create table index_demo(c1 INT,
                       	c2 INT,
                       	c3 CHAR(1),
                       	PRIMARY KEY(c1)
                        ) ROW_FORMAT = Compact;
```

​	index_demo 表中有两个int类型的列，一个char类型的列，主键是c1列，并且使用了Compact行结构来	存储记录。简化版index_demo行格式示意图：

![image-20230815170040509](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815170040509.png)

- **record_type**：记录头信息的一项属性，表示记录的类型，**0**表示普通记录，**2**表示最小记录，**3**表示最大记录，**1**表示目录页记录。

- **next_record**：记录头信息的一项属性，表示下一条地址相对于本条记录的偏移量，用箭头来表示下一条记录是谁。

- **各个列的值**：记录3个列值。

- **其他信息**：其他隐藏列的值和其他信息。

  把一些记录放到页里的示意图就是：

  ![image-20230815170604526](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815170604526.png)

##### 1. 简单的索引设计方案

​	因为每个数据页中的数据不存在规律，所以需要遍历所有的数据页来查找符合条件的数据。要想快速	的定位到需要查询的数据页，可以为数据页建立一个目录，以下是建立目录的条件：

 - **下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。**

 - **再给所有的页建立一个目录项。**

   ![image-20230815173017901](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815173017901.png)

   以页28为例，它对应目录项2，这个目录项中包含页号28，以及该页中用户记录最小主键值5。我们只需要把几个目录项在物理存储器上连续存储，比如用数组，就可以实现根据主键值快速查找某条记录的功能了。比如：查找主键值为20的用户记录，具体查找过程分两步：

   - 先从目录项根据二分法快速确定出记录所在的页，即在页9中。
   - 再次使用二分找到记录在页中的位置

##### 2. InnoDB中的索引方案

**① 迭代一次：目录项记录的页**

​	把前边使用到的目录项放到数据页中的样子，如下：

![image-20230815174238299](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815174238299.png)

​	从图中可以看出，新分配了一个编号为30的页来专门存储目录项记录。

​	**目录项记录**和**用户记录**的**不同点**：

- 目录项记录的**record_type**值是1，而普通用户记录的**record_type**值是0。
- 目录项记录只有主键值和页编号两列，而普通的用户记录的列是可以自定义的。

**② 迭代二次：多个目录项记录的页**

![image-20230815174847426](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815174847426.png)

​	在插入一条主键值为320的用户记录之后需要两个新的数据页：

- 存储用户记录而生成了新的数据页31。

- 原先存储目录项记录的页30已满(假设只能存4条)，需要新的数据页32来存储页31对应的目录项。

  因为现在存储的目录项记录的页不止一个，所以要查找主键值为20的数据记录需要分为3个步骤：

- 确定目录项记录页，主键值为20 < 320，所以对应的目录项记录在页30中。
- 通过上面说到的两个步骤定位用户记录。

**③ 迭代三次：目录项记录页的目录页**

![image-20230815175516785](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815175516785.png)

​	如图，生成了一个存储更高级目录项的页33，这个页中的两条记录分别代表页30和页32，如果查询记	录的主键值在[1, 320)之间，则到页30中查找记录，主键值若大于等于320到页32中查找记录，此时这	种数据结构可以描述成下图：

![image-20230815180158031](https://raw.githubusercontent.com/Ybszzzziz/docs/master/test/image-20230815180158031.png)

​	这个数据结构就是B+树。

**④ 迭代四次：B+Tree**

​	假设存放用户记录的叶子节点代表的数据页最多可以存放100条用户记录，所有存放目录项的节点可以存放1000条目录项记录，那么：

- 如果B+树只有一层，也就是只有一个用于存放用户记录的节点，最多能存放100条记录。

- 有两层，最多能存放1000 * 100 = 100000条记录。

- 三层，最多能存放1000 * 1000 * 100 = 1,0000,0000条记录。

- 四层，最多能存放1000 * 1000 * 1000 * 100 = 1,0000,0000,0000条记录

  所以一般情况下，用到的B+树不会超过四层，那通过主键值去查找用户记录，最多只需要四个页面的查找，在用户记录页又可以使用二分法快速定位记录，所以极大的提高了查询效率，降低了磁盘IO。

#### **问题**

1. **为什么二级索引中的叶子节点不放完整数据？**

   ​		当我们在创建表时，如果没有指定主键或者没有唯一非空索引，则InnoDB会自动为该表生成一个隐藏的聚簇索引，该聚簇索引的键值是一个以物理存储顺序排列的行标识符（也称为聚簇索引键）。聚簇索引键定义了数据在磁盘上的物理顺序，使得对于相邻数据的访问更加高效。而次要索引则引用了聚簇索引键，并在叶子节点中存储了聚簇索引键及部分非主键列的值。这样做的好处是减少了次要索引的存储空间，减少了数据冗余，同时通过与聚簇索引键的关联，可以更快地找到相应的数据行。虽然次要索引叶子节点中不存储完整的数据，但通过聚簇索引键的引用，InnoDB可以通过二级索引进行快速的索引查找，并在需要的时候通过聚簇索引键找到完整的数据行。需要注意的是，InnoDB的索引结构设计是一种权衡，旨在提高检索性能和存储效率。不同的数据库引擎可能采用不同的索引结构和实现方式，具体选择何种结构取决于数据的特点和应用需求。

2. **为什么使用索引**

   - 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性
   - 加快数据检索速度
   - 帮助服务器避免排序和临时表
   - 将随机IO变为顺序IO
   - 加速表与表之间的连接，特别是在实现数据的参考完整性方面有特别的意义

3. **Innodb为什么使用自增id作为主键**

   ​		如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。

4. **MyISAM和InnoDB实现BTree索引方式的区别是什么？**

   - MyISAM，B+Tree叶节点的data域存放的是数据记录的地址，在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域的值（存储的是数据地址的偏移量），然后以data域的值为地址读取相应的数据记录，这被称为“非聚簇索引”，二级索引。

   - InnoDB，其数据文件本身就是索引文件，相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的节点data域保存了完整的数据记录，这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引，这被称为“聚簇索引”或者聚集索引，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。

     ​		在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。因此，在设计表的时候，不建议使用过长的字段为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂